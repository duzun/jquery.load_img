{"version":3,"file":"load_img.min.js","sources":["../load_img.js"],"sourcesContent":["/**\n *  Load images asynchronously and cache them.\n *\n *  @license MIT\n *  @git https://github.com/duzun/jquery.load_img\n *  @author Dumitru Uzun (DUzun.Me)\n *  @version 1.6.0\n */\n\n// ---------------------------------------------------------------------------\nconst VERSION   = '1.6.0';\n\ninit.VERSION = VERSION;\n\nexport default function init($, global) {\n        if (!global) global = getGlobal();\n\n        var undefined; //jshint ignore:line\n\n        // ---------------------------------------------------------------------------\n        const { document } = global\n        ,   cache = {}\n        ,   errors = {}\n        ;\n\n        /**\n         * Load an image to cache.\n         *\n         * @param string src - source URL of the iamge\n         * @param callback clb.call(img: $(Image), src|false, event: $.Event)\n         *\n         * @return $(Image) element\n         */\n        function load_img(src, options, clb) {\n            if(!clb && typeof options == 'function') {\n                clb = options;\n                options = undefined;\n            }\n\n            options = options ? $.extend({}, load_img.settings, options) : load_img.settings;\n            const { errorExpires, decode } = options;\n\n            var img = $('<img />')\n            ,   hasClb = 'function' == typeof clb\n            ,   defered = hasClb ? undefined : new $.Deferred()\n            ,   onEvent = function (evt) {\n                    var type = evt.type\n                    ,   error = type == 'error'\n                    ;\n\n                    if (!evt.timeStamp) {\n                        evt.timeStamp = Date.now();\n                    }\n                    evt.src = src;\n                    if(error) {\n                        errors[src] = evt;\n                    }\n                    else {\n                        delete errors[src];\n                    }\n                    cache[src] = !error;\n                    img.off(error ? 'load' : 'error', onEvent).remove();\n                    img.show();\n                    if(hasClb) {\n                        if (decode && !error && img[0].decode) {\n                            img[0].decode()\n                            .then(\n                                () => clb.call(img, src, evt),\n                                (error) => {\n                                    evt.reason = error;\n                                    clb.call(img, false, evt);\n                                }\n                            );\n                        }\n                        else {\n                            clb.call(img, error?false:src, evt);\n                        }\n                    }\n                    else if ( defered ) {\n                        if ( error ) {\n                            defered.reject(evt);\n                        }\n                        else {\n                            if (decode && img[0].decode) {\n                                img[0].decode().then(() => defered.resolve(evt, src), defered.reject);\n                            }\n                            else {\n                                defered.resolve(evt, src);\n                            }\n                        }\n                    }\n                }\n            ,   that = this\n            ,   ctx = that && that != $ && that.$ctx\n            ;\n\n            if ( defered ) {\n                defered.promise(img);\n            }\n\n            img\n                .hide()\n                .one('load', onEvent)\n                .one('error', onEvent)\n            ;\n\n            let errorEvt = errors[src];\n            if (errorEvt && errorExpires && errorExpires < Date.now() - errorEvt.timeStamp) {\n                errorEvt = undefined;\n            }\n\n            if (errorEvt) {\n                img.prop('src', src).trigger(errorEvt);\n            }\n            else {\n                if(!ctx || !ctx.length || ctx[0] == document) {\n                    ctx = $(document.body||'body');\n                }\n                if(!ctx.length) {\n                    var tio = setInterval(function () {\n                        if(document.body) {\n                            clearInterval(tio);\n                            ctx = $(document.body);\n                            img.prop('src', src);\n                            ctx.append(img);\n                        }\n                    }, 50);\n                }\n                else {\n                    img.prop('src', src);\n                    ctx.append(img);\n                }\n            }\n            return img;\n        }\n\n        /**\n         * Check whether src has beed loaded (either success or error)\n         *\n         * @param string src - source URL of the iamge\n         *\n         * @return bool true if src in cache, false otherwise\n         */\n        function inCache(src) {\n            return src in cache;\n        }\n\n        /**\n         * Check whether image with src exists.\n         *\n         * @param string src - source URL of the iamge\n         * @param callback cb(src|false)\n         *\n         * Note: If cb supplied and src not in cache, it will trigger\n         *\n         * @return bool|undefined true if exists (and cached), false if doesn't exist (error on load), undefined if never loaded (not in cache)\n         */\n        function exists(src, cb) {\n            if ( src in cache ) {\n                cb && cb(cache[src]&&src);\n                return cache[src];\n            }\n            else {\n                cb && load_img(src, cb);\n            }\n        }\n\n        /**\n         * Get just the src of the image after preloading it.\n         *\n         * If the image is already preloaded, just resolve with the src.\n         *\n         * @param {string} src\n         * @param {object} options\n         * @returns {Promise<string>}\n         */\n        function loadSrc(src, options) {\n\n            if (exists(src)) {\n                let defered = $.Deferred();\n                let promise = defered.promise();\n                defered.resolve(src);\n                return promise;\n            }\n\n            return load_img(src, options)\n            .then((evt) => {\n                const { src, target } = evt;\n                return src || target && target.src;\n            });\n        }\n\n        function isImgOk(img) {\n            if ( !img.complete ) return false; /* Only IE is correct here */\n            if ( typeof img.naturalWidth != 'undefined' && img.naturalWidth == 0 ) return false; /* Other Browsers */\n            return true; /* No other way of checking: assume it's ok. */\n        }\n\n        /**\n         * Purce the cache.\n         */\n        function purgeCache() {\n            $.each(cache, function (n,v) {\n                delete cache[n];\n            });\n\n            $.each(errors, function (n,v) {\n                delete errors[n];\n            });\n        }\n\n        // Export\n\n        load_img.exists      = exists;\n        load_img.src         = loadSrc;\n        load_img.inCache     = load_img.in_cache    = inCache;\n        load_img.isImgOk     = load_img.is_ok       = isImgOk;\n        load_img.purgeCache  = load_img.purge_cache = purgeCache;\n\n        load_img.cache       = cache;\n        load_img.errors      = errors;\n        load_img.VERSION     = VERSION;\n\n        load_img.settings = {\n            errorExpires: 1e3, // after how many milliseconds to allow to retry loading an image which errored\n            decode: !!Image.prototype.decode, // wait for decode after loading the image\n        };\n\n        return $.load_img = load_img;\n}\n\nfunction getGlobal() {\n    return typeof globalThis != 'undefined' ? globalThis : typeof window != 'undefined' ? window : global;\n}\n\n;(function (global) {\n    const $ = global.jQuery || global.Zepto;\n    if ($) init($, global);\n}(getGlobal()));\n"],"names":["VERSION","init","$","global","undefined","getGlobal","document","cache","errors","load_img","src","options","clb","_options","extend","settings","errorExpires","decode","img","hasClb","defered","Deferred","onEvent","evt","error","type","timeStamp","Date","now","off","remove","show","then","call","reason","reject","resolve","that","this","ctx","$ctx","promise","hide","one","errorEvt","prop","trigger","length","body","append","tio","setInterval","clearInterval","exists","cb","target","inCache","in_cache","isImgOk","is_ok","complete","naturalWidth","purgeCache","purge_cache","each","n","v","Image","prototype","globalThis","window","jQuery","Zepto"],"mappings":"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"}